# -*- coding: utf-8 -*-
"""Untitled20.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UZwKeV50kftez1pdMm9DJrVHynL6no06
"""

import pandas as pd

# 불러온 CSV 파일을 DataFrame으로 변환
data = pd.read_csv('/content/202212-divvy-tripdata.csv')


# 데이터 확인
print(data.head())
# 방법 1: shape 속성 사용
row_count = data.shape[0]

# 방법 2: len() 함수 사용
row_count = len(data)

# 행 갯수 출력
print("총 행 갯수:", row_count)

data.head()

print(data.head())
print(data.info())

# 중복 데이터 확인
print(data.duplicated().sum())

# 이상치 확인 (예: 너무 긴 또는 짧은 대여 시간)
# 이 부분은 데이터의 특성에 따라 달라질 수 있습니다.

# 데이터의 최신성 확인
# 이 부분은 '시작 시간' 또는 '종료 시간' 열을 확인하여 진행할 수 있습니다.
print(data['started_at'].max())
print(data['ended_at'].max())

# 누락된 값 확인
print(data.isnull().sum())

# 데이터 형식 검증
# 예를 들어, 날짜/시간 열이 올바른 datetime 형식으로 되어 있는지 확인
# data['start_time'] = pd.to_datetime(data['start_time'], errors='coerce')
# data['end_time'] = pd.to_datetime(data['end_time'], errors='coerce')
# print(data.info())

# 시작 지점과 종료 지점을 위도와 경도로 구분하여 유일한 역 정보를 추출
unique_start_stations = data.dropna(subset=['start_station_name', 'start_station_id']).drop_duplicates(['start_lat', 'start_lng'])
unique_end_stations = data.dropna(subset=['end_station_name', 'end_station_id']).drop_duplicates(['end_lat', 'end_lng'])

# 누락된 시작 역 정보 채우기
for index, row in data.iterrows():
    if pd.isnull(row['start_station_name']) or pd.isnull(row['start_station_id']):
        match = unique_start_stations[(unique_start_stations['start_lat'] == row['start_lat']) & (unique_start_stations['start_lng'] == row['start_lng'])]
        if not match.empty:
            data.at[index, 'start_station_name'] = match.iloc[0]['start_station_name']
            data.at[index, 'start_station_id'] = match.iloc[0]['start_station_id']

# 누락된 종료 역 정보 채우기
for index, row in data.iterrows():
    if pd.isnull(row['end_station_name']) or pd.isnull(row['end_station_id']):
        match = unique_end_stations[(unique_end_stations['end_lat'] == row['end_lat']) & (unique_end_stations['end_lng'] == row['end_lng'])]
        if not match.empty:
            data.at[index, 'end_station_name'] = match.iloc[0]['end_station_name']
            data.at[index, 'end_station_id'] = match.iloc[0]['end_station_id']

# 누락된 값 확인
print(data.isnull().sum())

# 데이터 형식 검증
# 예를 들어, 날짜/시간 열이 올바른 datetime 형식으로 되어 있는지 확인
# data['start_time'] = pd.to_datetime(data['start_time'], errors='coerce')
# data['end_time'] = pd.to_datetime(data['end_time'], errors='coerce')
# print(data.info())

data['started_at'] = pd.to_datetime(data['started_at'])
data['ended_at'] = pd.to_datetime(data['ended_at'])

data['trip_duration'] = data['ended_at'] - data['started_at']

# 요금 체계 설정
member_rate_per_week = 25  # 멤버 사용자의 주당 요금
casual_rate_per_minute = 0.45  # 캐주얼 사용자의 분당 요금

# 'trip_duration'이 timedelta 타입인 경우, 초 단위로 변환
data['trip_duration_seconds'] = data['trip_duration'].dt.total_seconds()

# 멤버 사용자의 수익 계산
member_revenue = data[data['member_casual'] == 'member'].shape[0] * member_rate_per_week

# 캐주얼 사용자의 수익 계산
casual_revenue = (data[data['member_casual'] == 'casual']['trip_duration_seconds'].sum() / 60) * casual_rate_per_minute

# 결과 출력
print(f"멤버 사용자의 수익: ${member_revenue:,.2f}")
print(f"캐주얼 사용자의 수익: ${casual_revenue:,.2f}")

member_usage_frequency = data[data['member_casual'] == 'member'].shape[0]
casual_usage_frequency = data[data['member_casual'] == 'casual'].shape[0]
# 이용 빈도 출력
print("회원의 이용 빈도:", member_usage_frequency)
print("비회원의 이용 빈도:", casual_usage_frequency)

# 'rideable_type' 컬럼을 기반으로 바이크 종류별 비율 계산
bike_type_counts = data['rideable_type'].value_counts(normalize=True) * 100

# 결과 출력
bike_type_counts

# 각 스테이션별로 electric_bike와 classic_bike의 사용 횟수 계산
station_bike_usage = data.groupby(['start_station_id', 'rideable_type']).size().unstack(fill_value=0)

# electric_bike와 classic_bike만 선택
station_bike_usage = station_bike_usage[['electric_bike', 'classic_bike']]

# 각 스테이션의 총 사용 횟수를 기준으로 상위 20개 스테이션 추출
top_20_stations = station_bike_usage.sum(axis=1).nlargest(20).index

# 상위 20개 스테이션에서의 electric_bike와 classic_bike 사용 횟수
top_20_station_usage = station_bike_usage.loc[top_20_stations]

# 결과 출력
print(top_20_station_usage)

data.dropna(inplace=True)

row_count = data.shape[0]

# 방법 2: len() 함수 사용
row_count = len(data)

# 행 갯수 출력
print("총 행 갯수:", row_count)

trip_data = data[['started_at', 'ended_at', 'trip_duration']]

trip_data['trip_duration'].min()

# 'trip_duration'이 음수인 행을 필터링
negative_duration_data = data[data['trip_duration'] < pd.Timedelta(0)]

# 결과 확인
print(negative_duration_data)

number_of_rows =len(negative_duration_data)
number_of_rows

data['trip_duration'].describe()

ratio_caual_member=casual_usage_frequency/(member_usage_frequency + casual_usage_frequency)
ratio_caual_member

data.head()

# 이용 시간대(시간) 추가
data['hour_of_day'] = data['started_at'].dt.hour

# 멤버와 캐주얼 사용자별 이용 시간대 분포 계산
member_hour_usage = data[data['member_casual'] == 'member']['hour_of_day'].value_counts().sort_index()
casual_hour_usage = data[data['member_casual'] == 'casual']['hour_of_day'].value_counts().sort_index()

# 멤버와 캐주얼 사용자별 주요 이용 스테이션 계산
member_start_stations = data[data['member_casual'] == 'member']['start_station_name'].value_counts()
casual_start_stations = data[data['member_casual'] == 'casual']['start_station_name'].value_counts()

# 결과 출력
print("멤버 이용 시간대 분포:\n", member_hour_usage)
print("\n캐주얼 이용 시간대 분포:\n", casual_hour_usage)
print("\n멤버 주요 시작 스테이션:\n", member_start_stations.head())
print("\n캐주얼 주요 시작 스테이션:\n", casual_start_stations.head())

# 관심 있는 스테이션 이름 리스트
stations = [ 'Shedd Aquarium',
'Streeter Dr & Grand Ave',
'Kingsbury St & Kinzie St',
'Clark St & Newport St',
'Clark St & Elm St'

]

# 각 스테이션의 위도와 경도 정보를 추출
station_coordinates = {}
for station in stations:
    station_data = data[data['start_station_name'] == station].iloc[0]
    station_coordinates[station] = {
        'start_lat': station_data['start_lat'],
        'start_lng': station_data['start_lng']
    }

# 추출한 정보를 출력
for station, coords in station_coordinates.items():
    print(f"{station}: 위도 {coords['start_lat']}, 경도 {coords['start_lng']}")

import math
import pandas as pd
# Haversine 공식을 사용하여 거리 계산하는 함수
def haversine(lat1, lon1, lat2, lon2):
    # 지구 반경 (km 단위)
    R = 6371.0

    # 위도, 경도를 라디안으로 변환
    lat1 = math.radians(lat1)
    lon1 = math.radians(lon1)
    lat2 = math.radians(lat2)
    lon2 = math.radians(lon2)

    # 위도와 경도의 차이
    dlat = lat2 - lat1
    dlon = lon2 - lon1

    # Haversine 공식
    a = math.sin(dlat / 2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2)**2
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))

    # 최종 거리
    distance = R * c
    return distance

# 데이터 프레임의 각 행에 대해 거리 계산
data['distance'] = data.apply(lambda row: haversine(row['start_lat'], row['start_lng'], row['end_lat'], row['end_lng']), axis=1)

# 결과 확인
print(data[['start_lat', 'start_lng', 'end_lat', 'end_lng', 'distance']].head())

# 'distance' 컬럼을 이용하여 멤버와 캐주얼 사용자의 평균 거리 계산
member_avg_distance = data[data['member_casual'] == 'member']['distance'].mean()
casual_avg_distance = data[data['member_casual'] == 'casual']['distance'].mean()

# 결과 출력
print(f"멤버 사용자의 평균 거리: {member_avg_distance} km")
print(f"캐주얼 사용자의 평균 거리: {casual_avg_distance} km")

data.head()

# 'start_station_name'과 'end_station_name'을 결합하여 경로 생성
data['route'] = data['start_station_name'] + " to " + data['end_station_name']

# 멤버와 캐주얼 사용자별로 가장 많이 이용된 경로 계산
member_routes = data[data['member_casual'] == 'member']['route'].value_counts().head(10)
casual_routes = data[data['member_casual'] == 'casual']['route'].value_counts().head(10)

# 결과 출력
print("멤버 사용자의 상위 이용 경로:\n", member_routes)
print("캐주얼 사용자의 상위 이용 경로:\n", casual_routes)

# 'route' 열 생성
data['route'] = data['start_station_name'] + " to " + data['end_station_name']

# 멤버와 캐주얼 사용자별로 가장 많이 이용된 경로 계산
member_routes = data[data['member_casual'] == 'member']['route'].value_counts().head(10)
casual_routes = data[data['member_casual'] == 'casual']['route'].value_counts().head(10)

# 경로에 대한 좌표 추출 함수
def get_route_coordinates(data, top_routes):
    route_coordinates = {}
    for route in top_routes.index:
        start_station, end_station = route.split(" to ")
        start_coords = data[data['start_station_name'] == start_station][['start_lat', 'start_lng']].iloc[0]
        end_coords = data[data['end_station_name'] == end_station][['end_lat', 'end_lng']].iloc[0]
        route_coordinates[route] = (start_coords.tolist(), end_coords.tolist())
    return route_coordinates

# 멤버 사용자의 상위 이용 경로 좌표
member_route_coords = get_route_coordinates(data, member_routes)

# 캐주얼 사용자의 상위 이용 경로 좌표
casual_route_coords = get_route_coordinates(data, casual_routes)

# 좌표 결과 확인
print("멤버 사용자의 상위 이용 경로 좌표:\n", member_route_coords)
print("캐주얼 사용자의 상위 이용 경로 좌표:\n", casual_route_coords)

import folium

# 멤버 사용자의 상위 이용 경로 좌표
member_route_coords = {
    'Ellis Ave & 60th St to University Ave & 57th St': ([41.78509416666667, -87.60108833333334], [41.791478, -87.599861]),
    'Ellis Ave & 60th St to Ellis Ave & 55th St': ([41.78509416666667, -87.60108833333334], [41.79430062054, -87.6014497734]),
    'University Ave & 57th St to Ellis Ave & 60th St': ([41.791512, -87.59993216666666], [41.78509714636, -87.6010727606]),
    'Ellis Ave & 55th St to Ellis Ave & 60th St': ([41.79430062054, -87.6014497734], [41.78509714636, -87.6010727606]),
    'State St & 33rd St to Calumet Ave & 33rd St': ([41.834722281, -87.625763297], [41.8349, -87.61793]),
     'Calumet Ave & 33rd St to State St & 33rd St': ([41.834852815, -87.617890954], [41.834734, -87.625813]),
    'Loomis St & Lexington St to Morgan St & Polk St': ([41.87222873224032, -87.66136385500431], [41.871737, -87.65103]),
    'Morgan St & Polk St to Loomis St & Lexington St': ([41.872038484, -87.650987387], [41.87222873224032, -87.66136385500431]),
    'University Ave & 57th St to Kimbark Ave & 53rd St': ([41.791512, -87.59993216666666], [41.799568, -87.594747]),
    'Ellis Ave & 58th St to Ellis Ave & 60th St': ([41.78856366666667, -87.601174], [41.78509714636, -87.6010727606])
}

# 캐주얼 사용자의 상위 이용 경로 좌표
casual_route_coords = {
    'Streeter Dr & Grand Ave to Streeter Dr & Grand Ave': ([41.892278, -87.612043], [41.892278, -87.612043]),
    'Ellis Ave & 60th St to Ellis Ave & 55th St': ([41.78509416666667, -87.60108833333334], [41.79430062054, -87.6014497734]),
    'DuSable Lake Shore Dr & Monroe St to DuSable Lake Shore Dr & Monroe St': ([41.880958, -87.616743], [41.880958, -87.616743]),
    'Ellis Ave & 55th St to Ellis Ave & 60th St': ([41.79430062054, -87.6014497734], [41.78509714636, -87.6010727606]),
    'DuSable Lake Shore Dr & Monroe St to Streeter Dr & Grand Ave': ([41.880958, -87.616743], [41.892278, -87.612043]),
    'Ellis Ave & 60th St to University Ave & 57th St': ([41.78509416666667, -87.60108833333334], [41.791478, -87.599861]),
    'University Ave & 57th St to Ellis Ave & 60th St': ([41.791512, -87.59993216666666], [41.78509714636, -87.6010727606]),
    'University Ave & 57th St to Kimbark Ave & 53rd St': ([41.791512, -87.59993216666666], [41.799568, -87.594747]),
    'Streeter Dr & Grand Ave to Millennium Park': ([41.892278, -87.612043], [41.881032, -87.624084]),
    'Sheffield Ave & Fullerton Ave to Greenview Ave & Fullerton Ave': ([41.92556283333333, -87.6537395], [41.92533, -87.6658])
}

# 지도 생성
m = folium.Map(location=[41.8781, -87.6298], zoom_start=12)

# 멤버 사용자의 경로 표시
for route, coords in member_route_coords.items():
    folium.PolyLine(coords, color="blue").add_to(m)

# 캐주얼 사용자의 경로 표시
for route, coords in casual_route_coords.items():
    folium.PolyLine(coords, color="red").add_to(m)

# 지도 표시
m.save("map.html")

import folium

# 캐주얼 사용자의 상위 이용 경로 좌표
casual_route_coords = {
    'Streeter Dr & Grand Ave to Streeter Dr & Grand Ave': ([41.892278, -87.612043], [41.892278, -87.612043]),
    'Ellis Ave & 60th St to Ellis Ave & 55th St': ([41.78509416666667, -87.60108833333334], [41.79430062054, -87.6014497734]),
    'DuSable Lake Shore Dr & Monroe St to DuSable Lake Shore Dr & Monroe St': ([41.880958, -87.616743], [41.880958, -87.616743]),
    'Ellis Ave & 55th St to Ellis Ave & 60th St': ([41.79430062054, -87.6014497734], [41.78509714636, -87.6010727606]),
    'DuSable Lake Shore Dr & Monroe St to Streeter Dr & Grand Ave': ([41.880958, -87.616743], [41.892278, -87.612043]),
    'Ellis Ave & 60th St to University Ave & 57th St': ([41.78509416666667, -87.60108833333334], [41.791478, -87.599861]),
    'University Ave & 57th St to Ellis Ave & 60th St': ([41.791512, -87.59993216666666], [41.78509714636, -87.6010727606]),
    'University Ave & 57th St to Kimbark Ave & 53rd St': ([41.791512, -87.59993216666666], [41.799568, -87.594747]),
    'Streeter Dr & Grand Ave to Millennium Park': ([41.892278, -87.612043], [41.881032, -87.624084]),
    'Sheffield Ave & Fullerton Ave to Greenview Ave & Fullerton Ave': ([41.92556283333333, -87.6537395], [41.92533, -87.6658])
}

# 이용 빈도
route_usage = {
    'Streeter Dr & Grand Ave to Streeter Dr & Grand Ave': 192,
    'Ellis Ave & 60th St to Ellis Ave & 55th St': 180,
    'DuSable Lake Shore Dr & Monroe St to DuSable Lake Shore Dr & Monroe St': 165,
    'Ellis Ave & 55th St to Ellis Ave & 60th St': 161,
    'DuSable Lake Shore Dr & Monroe St to Streeter Dr & Grand Ave': 155,
    'Ellis Ave & 60th St to University Ave & 57th St': 153,
    'University Ave & 57th St to Ellis Ave & 60th St': 133,
    'University Ave & 57th St to Kimbark Ave & 53rd St': 94,
    'Streeter Dr & Grand Ave to Millennium Park': 86,
    'Sheffield Ave & Fullerton Ave to Greenview Ave & Fullerton Ave': 81
}

# 지도 생성
m = folium.Map(location=[41.8781, -87.6298], zoom_start=12)

# 캐주얼 사용자의 경로 및 마커 표시
for route, coords in casual_route_coords.items():
    # 선의 굵기 설정 (이용 빈도에 따라 조정)
    line_weight = route_usage.get(route, 1) * 0.05  # 이용 빈도에 비례하여 선의 굵기를 조정

    # 경로 표시
    folium.PolyLine(coords, color="red", weight=line_weight,alpha=0.5).add_to(m)

    # 끝점에 마커 추가
    folium.Marker(coords[1], popup=route).add_to(m)

# 지도 저장
m.save("map.html")

# 'start_station_id'와 'end_station_id' 컬럼에서 중복 제거하고 스테이션 개수 계산
unique_stations = pd.concat([data['start_station_id'], data['end_station_id']]).unique()
number_of_stations = len(unique_stations)

# 결과 출력
print(f"중복 없는 스테이션의 총 개수: {number_of_stations}")

import folium


# 스테이션별 이용 빈도수 계산
station_usage_start = data['start_station_id'].value_counts()
station_usage_end = data['end_station_id'].value_counts()
station_usage = station_usage_start.add(station_usage_end, fill_value=0)

# 스테이션 위치 데이터 추출
station_locations = data.groupby('start_station_id').first()[['start_lat', 'start_lng']].dropna()

# 지도 생성
m = folium.Map(location=[station_locations['start_lat'].mean(), station_locations['start_lng'].mean()], zoom_start=12)

# 스테이션별 마커 추가
for station_id, row in station_locations.iterrows():
    usage = station_usage.get(station_id, 0)
    # 너무 큰 원을 방지하기 위한 크기 제한 설정
    radius = min(usage, 1000) * 2  # 최대 크기를 1000으로 제한
    folium.Circle(
        location=(row['start_lat'], row['start_lng']),
        radius=radius,
        color='blue',
        fill=True,
        fill_opacity=0.01,
        weight=0.1
    ).add_to(m)

# 지도 저장
m.save("map.html")

"""import pandas as pd
import folium


# 스테이션별 이용 빈도수 계산
station_usage_start = data['start_station_id'].value_counts()
station_usage_end = data['end_station_id'].value_counts()
station_usage = station_usage_start.add(station_usage_end, fill_value=0)

# 스테이션 이용 빈도의 중간값 계산
median_usage = station_usage.median()

# 중간값보다 높은 이용 빈도를 가진 스테이션 필터링
high_usage_stations = station_usage[station_usage > median_usage]

# 스테이션 위치 데이터 추출
station_locations = data.groupby('start_station_id').first()[['start_lat', 'start_lng']].dropna()

# 지도 생성
m = folium.Map(location=[station_locations['start_lat'].mean(), station_locations['start_lng'].mean()], zoom_start=12)

# 중간값보다 높은 이용 빈도를 가진 스테이션의 마커 추가
for station_id in high_usage_stations.index:
    if station_id in station_locations.index:
        row = station_locations.loc[station_id]
        folium.Circle(
            location=(row['start_lat'], row['start_lng']),
            radius=100,  # 고정된 반경 크기
            color='blue',
            fill=True,
            fill_opacity=0.5
        ).add_to(m)

# 지도 저장
m.save("map.html") """

# 'started_at' 컬럼을 datetime 타입으로 변환
data['started_at'] = pd.to_datetime(data['started_at'])

# 각 라이드가 시작된 요일 계산 (1 = 일요일, 7 = 토요일)
data['day_of_week'] = data['started_at'].dt.dayofweek + 1

# 전체 라이드의 요일별 빈도수 계산
overall_day_frequency = data['day_of_week'].value_counts().sort_index()

# 멤버와 캐주얼 사용자별 요일별 빈도수 계산
member_day_frequency = data[data['member_casual'] == 'member']['day_of_week'].value_counts().sort_index()
casual_day_frequency = data[data['member_casual'] == 'casual']['day_of_week'].value_counts().sort_index()

# 결과 출력
print("전체 요일별 빈도:  {0}".format(overall_day_frequency)),
print("회원 요일별 빈도:  {0}".format(member_day_frequency)),
print("비회원 요일별 빈도:  {0}".format(casual_day_frequency))

import matplotlib.pyplot as plt

# 전체 라이드의 요일별 빈도수 계산
overall_day_frequency = data['day_of_week'].value_counts().sort_index()

# 멤버와 캐주얼 사용자별 요일별 빈도수 계산
member_day_frequency = data[data['member_casual'] == 'member']['day_of_week'].value_counts().sort_index()
casual_day_frequency = data[data['member_casual'] == 'casual']['day_of_week'].value_counts().sort_index()

# 요일별 분포 그래프 그리기
plt.figure(figsize=(12, 6))
plt.plot(overall_day_frequency.index, overall_day_frequency.values, label='Overall', marker='o')
plt.plot(member_day_frequency.index, member_day_frequency.values, label='Member', marker='o')
plt.plot(casual_day_frequency.index, casual_day_frequency.values, label='Casual', marker='o')

# 그래프 제목 및 레이블 설정
plt.title('Day of the Week Usage Frequency')
plt.xlabel('Day of the Week (1=Sunday, 7=Saturday)')
plt.ylabel('Number of Rides')
plt.xticks(range(1, 8))
plt.legend()

# 그래프 표시
plt.show()

# 요일별 이용량 계산
data['day_of_week'] = data['started_at'].dt.day_name()

# 각 요일별 가장 높은 이용량을 가진 시간대 찾기
best_marketing_times = data.groupby('day_of_week')['started_at'].apply(lambda x: x.dt.hour.mode().iloc[0]).reset_index()

# 결과 출력
print("요일별 가장 적합한 마케팅 시간대:")
for index, row in best_marketing_times.iterrows():
    print(f"{row['day_of_week']}: {row['started_at']} 시")

# 요일과 시간대 계산
data['day_of_week'] = data['started_at'].dt.day_name()
data['hour_of_day'] = data['started_at'].dt.hour


# 요일과 시간대별 이용 횟수 계산
usage_by_day_hour = data.groupby(['day_of_week', 'hour_of_day']).size().reset_index(name='이용횟수')

# 상위 10개 조합 선택
top_10_times = usage_by_day_hour.nlargest(10, '이용횟수')

# 결과 출력
print("상위 10개 요일과 시간대별 이용 횟수:")
for index, row in top_10_times.iterrows():
    print(f"{row['day_of_week']} {row['hour_of_day']}시 - 이용횟수: {row['이용횟수']}회")

# 캐주얼 사용자만 선택
casual_data = data[data['member_casual'] == 'casual']

# 요일과 시간대 계산
casual_data['day_of_week'] = casual_data['started_at'].dt.day_name()
casual_data['hour_of_day'] = casual_data['started_at'].dt.hour

# 요일과 시간대별 이용 횟수 계산
usage_by_day_hour = casual_data.groupby(['day_of_week', 'hour_of_day']).size().reset_index(name='이용횟수')

# 상위 10개 조합 선택
top_10_times = usage_by_day_hour.nlargest(10, '이용횟수')

# 결과 출력
print("캐주얼 사용자 상위 10개 요일과 시간대별 이용 횟수:")
for index, row in top_10_times.iterrows():
    print(f"{row['day_of_week']} {row['hour_of_day']}시 - 이용횟수: {row['이용횟수']}회")