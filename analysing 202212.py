# -*- coding: utf-8 -*-
"""Untitled20.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UZwKeV50kftez1pdMm9DJrVHynL6no06
"""

import pandas as pd

# 불러온 CSV 파일을 DataFrame으로 변환
data = pd.read_csv('/content/202212-divvy-tripdata.csv')


# 데이터 확인
print(data.head())
# 방법 1: shape 속성 사용
row_count = data.shape[0]

# 방법 2: len() 함수 사용
row_count = len(data)

# 행 갯수 출력
print("총 행 갯수:", row_count)

data.head()

print(data.head())
print(data.info())

# 중복 데이터 확인
print(data.duplicated().sum())

# 이상치 확인 (예: 너무 긴 또는 짧은 대여 시간)
# 이 부분은 데이터의 특성에 따라 달라질 수 있습니다.

# 데이터의 최신성 확인
# 이 부분은 '시작 시간' 또는 '종료 시간' 열을 확인하여 진행할 수 있습니다.
print(data['started_at'].max())
print(data['ended_at'].max())

# 누락된 값 확인
print(data.isnull().sum())

# 데이터 형식 검증
# 예를 들어, 날짜/시간 열이 올바른 datetime 형식으로 되어 있는지 확인
# data['start_time'] = pd.to_datetime(data['start_time'], errors='coerce')
# data['end_time'] = pd.to_datetime(data['end_time'], errors='coerce')
# print(data.info())

# 시작 지점과 종료 지점을 위도와 경도로 구분하여 유일한 역 정보를 추출
unique_start_stations = data.dropna(subset=['start_station_name', 'start_station_id']).drop_duplicates(['start_lat', 'start_lng'])
unique_end_stations = data.dropna(subset=['end_station_name', 'end_station_id']).drop_duplicates(['end_lat', 'end_lng'])

# 누락된 시작 역 정보 채우기
for index, row in data.iterrows():
    if pd.isnull(row['start_station_name']) or pd.isnull(row['start_station_id']):
        match = unique_start_stations[(unique_start_stations['start_lat'] == row['start_lat']) & (unique_start_stations['start_lng'] == row['start_lng'])]
        if not match.empty:
            data.at[index, 'start_station_name'] = match.iloc[0]['start_station_name']
            data.at[index, 'start_station_id'] = match.iloc[0]['start_station_id']

# 누락된 종료 역 정보 채우기
for index, row in data.iterrows():
    if pd.isnull(row['end_station_name']) or pd.isnull(row['end_station_id']):
        match = unique_end_stations[(unique_end_stations['end_lat'] == row['end_lat']) & (unique_end_stations['end_lng'] == row['end_lng'])]
        if not match.empty:
            data.at[index, 'end_station_name'] = match.iloc[0]['end_station_name']
            data.at[index, 'end_station_id'] = match.iloc[0]['end_station_id']

# 누락된 값 확인
print(data.isnull().sum())

# 데이터 형식 검증
# 예를 들어, 날짜/시간 열이 올바른 datetime 형식으로 되어 있는지 확인
# data['start_time'] = pd.to_datetime(data['start_time'], errors='coerce')
# data['end_time'] = pd.to_datetime(data['end_time'], errors='coerce')
# print(data.info())

data['started_at'] = pd.to_datetime(data['started_at'])
data['ended_at'] = pd.to_datetime(data['ended_at'])

data['trip_duration'] = data['ended_at'] - data['started_at']

# 요금 체계 설정
member_rate_per_week = 25  # 멤버 사용자의 주당 요금
casual_rate_per_minute = 0.45  # 캐주얼 사용자의 분당 요금

# 'trip_duration'이 timedelta 타입인 경우, 초 단위로 변환
data['trip_duration_seconds'] = data['trip_duration'].dt.total_seconds()

# 멤버 사용자의 수익 계산
member_revenue = data[data['member_casual'] == 'member'].shape[0] * member_rate_per_week

# 캐주얼 사용자의 수익 계산
casual_revenue = (data[data['member_casual'] == 'casual']['trip_duration_seconds'].sum() / 60) * casual_rate_per_minute

# 결과 출력
print(f"멤버 사용자의 수익: ${member_revenue:,.2f}")
print(f"캐주얼 사용자의 수익: ${casual_revenue:,.2f}")

member_usage_frequency = data[data['member_casual'] == 'member'].shape[0]
casual_usage_frequency = data[data['member_casual'] == 'casual'].shape[0]
# 이용 빈도 출력
print("회원의 이용 빈도:", member_usage_frequency)
print("비회원의 이용 빈도:", casual_usage_frequency)

import matplotlib.pyplot as plt

# 'member'와 'casual'에 대한 수익(revenues)과 이용 빈도(frequencies) 계산
# 여기서는 임의의 수익과 이용 빈도 값을 사용합니다. 실제 데이터에 따라 이 값을 조정해야 할 수 있습니다.
revenues = [data[data['member_casual'] == 'member'].shape[0] * 10,  # 예시: 멤버당 $10 수익 가정
           data[data['member_casual'] == 'casual'].shape[0] * 5]   # 예시: 비회원당 $5 수익 가정
frequencies = [data[data['member_casual'] == 'member'].shape[0],
               data[data['member_casual'] == 'casual'].shape[0]]

categories = ['member', 'casual']
positions = range(len(categories))
width = 0.4  # 막대 너비

fig, ax1 = plt.subplots(figsize=(8, 6))

# Revenue (수익)을 위한 막대 차트
color = 'tab:blue'
ax1.set_xlabel('Membership Type')
ax1.set_ylabel('Revenue ($)', color=color)
ax1.bar([p - width/2 for p in positions], revenues, width=width, color=color)
ax1.tick_params(axis='y', labelcolor=color)

# 왼쪽 y축 눈금 레이블에 'M' 추가
def millions_formatter(x, pos):
    return f'{x / 1_000_000}M'
ax1.yaxis.set_major_formatter(plt.FuncFormatter(millions_formatter))

# Frequency (이용 빈도)를 위한 막대 차트, y축을 오른쪽에 설정하고 눈금 조정
ax2 = ax1.twinx()
color = 'tab:orange'
ax2.set_ylabel('Frequency', color=color)
ax2.bar([p + width/2 for p in positions], frequencies, width=width, color=color)
ax2.tick_params(axis='y', labelcolor=color)
ax2.set_ylim(0, 160000)  # y축 범위를 0에서 160,000으로 설정

# x축 레이블 설정
ax1.set_xticks(positions)
ax1.set_xticklabels(categories)

plt.title('Comparison of Revenue and Frequency by Membership Type')
fig.tight_layout()

# 차트를 표시
plt.show()

# 'rideable_type' 컬럼을 기반으로 바이크 종류별 비율 계산
bike_type_counts = data['rideable_type'].value_counts(normalize=True) * 100

# 결과 출력
bike_type_counts

# 각 스테이션별로 electric_bike와 classic_bike의 사용 횟수 계산
station_bike_usage = data.groupby(['start_station_id', 'rideable_type']).size().unstack(fill_value=0)

# electric_bike와 classic_bike만 선택
station_bike_usage = station_bike_usage[['electric_bike', 'classic_bike']]

# 각 스테이션의 총 사용 횟수를 기준으로 상위 20개 스테이션 추출
top_20_stations = station_bike_usage.sum(axis=1).nlargest(20).index

# 상위 20개 스테이션에서의 electric_bike와 classic_bike 사용 횟수
top_20_station_usage = station_bike_usage.loc[top_20_stations]

# 결과 출력
print(top_20_station_usage)

data.dropna(inplace=True)

row_count = data.shape[0]

# 방법 2: len() 함수 사용
row_count = len(data)

# 행 갯수 출력
print("총 행 갯수:", row_count)

trip_data = data[['started_at', 'ended_at', 'trip_duration']]

trip_data['trip_duration'].min()

# 'trip_duration'이 음수인 행을 필터링
negative_duration_data = data[data['trip_duration'] < pd.Timedelta(0)]

# 결과 확인
print(negative_duration_data)

number_of_rows =len(negative_duration_data)
number_of_rows

data['trip_duration'].describe()

ratio_caual_member=casual_usage_frequency/(member_usage_frequency + casual_usage_frequency)
ratio_caual_member

data.head()

# 이용 시간대(시간)추가
data['hour_of_day'] = data['started_at'].dt.hour

# 멤버와 캐주얼 사용자별 이용 시간대 분포 계산
member_hour_usage = data[data['member_casual'] == 'member']['hour_of_day'].value_counts().sort_index()
casual_hour_usage = data[data['member_casual'] == 'casual']['hour_of_day'].value_counts().sort_index()

# 멤버와 캐주얼 사용자별 주요 이용 스테이션 계산
member_start_stations = data[data['member_casual'] == 'member']['start_station_name'].value_counts()
casual_start_stations = data[data['member_casual'] == 'casual']['start_station_name'].value_counts()

# 결과 출력
print("멤버 이용 시간대 분포:\n", member_hour_usage)
print("\n캐주얼 이용 시간대 분포:\n", casual_hour_usage)
print("\n멤버 주요 시작 스테이션:\n", member_start_stations.head())
print("\n캐주얼 주요 시작 스테이션:\n", casual_start_stations.head(10))



# 관심 있는 스테이션 이름 리스트
stations = [ 'Shedd Aquarium',
'Streeter Dr & Grand Ave',
'Millennium Park',
'DuSable Lake Shore Dr & Monroe St',
'Kingsbury St & Kinzie St',
'Clark St & Newport St',
'LaSalle St & Illinois St',
'Clark St & Elm St',
'Wabash Ave & Grand Ave',
'Michigan Ave & 8th St'

]

# 각 스테이션의 위도와 경도 정보를 추출
station_coordinates = {}
for station in stations:
    station_data = data[data['start_station_name'] == station].iloc[0]
    station_coordinates[station] = {
        'start_lat': station_data['start_lat'],
        'start_lng': station_data['start_lng']
    }

# 추출한 정보를 출력
for station, coords in station_coordinates.items():
    print(f"{station}: 위도 {coords['start_lat']}, 경도 {coords['start_lng']}")

import math
import pandas as pd
# Haversine 공식을 사용하여 거리 계산하는 함수
def haversine(lat1, lon1, lat2, lon2):
    # 지구 반경 (km 단위)
    R = 6371.0

    # 위도, 경도를 라디안으로 변환
    lat1 = math.radians(lat1)
    lon1 = math.radians(lon1)
    lat2 = math.radians(lat2)
    lon2 = math.radians(lon2)

    # 위도와 경도의 차이
    dlat = lat2 - lat1
    dlon = lon2 - lon1

    # Haversine 공식
    a = math.sin(dlat / 2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2)**2
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))

    # 최종 거리
    distance = R * c
    return distance

# 데이터 프레임의 각 행에 대해 거리 계산
data['distance'] = data.apply(lambda row: haversine(row['start_lat'], row['start_lng'], row['end_lat'], row['end_lng']), axis=1)

# 결과 확인
print(data[['start_lat', 'start_lng', 'end_lat', 'end_lng', 'distance']].head())

# 'distance' 컬럼을 이용하여 멤버와 캐주얼 사용자의 평균 거리 계산
member_avg_distance = data[data['member_casual'] == 'member']['distance'].mean()
casual_avg_distance = data[data['member_casual'] == 'casual']['distance'].mean()

# 결과 출력
print(f"멤버 사용자의 평균 거리: {member_avg_distance} km")
print(f"캐주얼 사용자의 평균 거리: {casual_avg_distance} km")

data.head()

# 'start_station_name'과 'end_station_name'을 결합하여 경로 생성
data['route'] = data['start_station_name'] + " to " + data['end_station_name']

# 멤버와 캐주얼 사용자별로 가장 많이 이용된 경로 계산
member_routes = data[data['member_casual'] == 'member']['route'].value_counts().head(10)
casual_routes = data[data['member_casual'] == 'casual']['route'].value_counts().head(10)

# 결과 출력
print("멤버 사용자의 상위 이용 경로:\n", member_routes)
print("캐주얼 사용자의 상위 이용 경로:\n", casual_routes)

# 'route' 열 생성
data['route'] = data['start_station_name'] + " to " + data['end_station_name']

# 멤버와 캐주얼 사용자별로 가장 많이 이용된 경로 계산
member_routes = data[data['member_casual'] == 'member']['route'].value_counts().head(10)
casual_routes = data[data['member_casual'] == 'casual']['route'].value_counts().head(10)

# 경로에 대한 좌표 추출 함수
def get_route_coordinates(data, top_routes):
    route_coordinates = {}
    for route in top_routes.index:
        start_station, end_station = route.split(" to ")
        start_coords = data[data['start_station_name'] == start_station][['start_lat', 'start_lng']].iloc[0]
        end_coords = data[data['end_station_name'] == end_station][['end_lat', 'end_lng']].iloc[0]
        route_coordinates[route] = (start_coords.tolist(), end_coords.tolist())
    return route_coordinates

# 멤버 사용자의 상위 이용 경로 좌표
member_route_coords = get_route_coordinates(data, member_routes)

# 캐주얼 사용자의 상위 이용 경로 좌표
casual_route_coords = get_route_coordinates(data, casual_routes)

# 좌표 결과 확인
print("멤버 사용자의 상위 이용 경로 좌표:\n", member_route_coords)
print("캐주얼 사용자의 상위 이용 경로 좌표:\n", casual_route_coords)

import folium

# 멤버 사용자의 상위 이용 경로 좌표
member_route_coords = {
    'Ellis Ave & 60th St to University Ave & 57th St': ([41.78509416666667, -87.60108833333334], [41.791478, -87.599861]),
    'Ellis Ave & 60th St to Ellis Ave & 55th St': ([41.78509416666667, -87.60108833333334], [41.79430062054, -87.6014497734]),
    'University Ave & 57th St to Ellis Ave & 60th St': ([41.791512, -87.59993216666666], [41.78509714636, -87.6010727606]),
    'Ellis Ave & 55th St to Ellis Ave & 60th St': ([41.79430062054, -87.6014497734], [41.78509714636, -87.6010727606]),
    'State St & 33rd St to Calumet Ave & 33rd St': ([41.834722281, -87.625763297], [41.8349, -87.61793]),
     'Calumet Ave & 33rd St to State St & 33rd St': ([41.834852815, -87.617890954], [41.834734, -87.625813]),
    'Loomis St & Lexington St to Morgan St & Polk St': ([41.87222873224032, -87.66136385500431], [41.871737, -87.65103]),
    'Morgan St & Polk St to Loomis St & Lexington St': ([41.872038484, -87.650987387], [41.87222873224032, -87.66136385500431]),
    'University Ave & 57th St to Kimbark Ave & 53rd St': ([41.791512, -87.59993216666666], [41.799568, -87.594747]),
    'Ellis Ave & 58th St to Ellis Ave & 60th St': ([41.78856366666667, -87.601174], [41.78509714636, -87.6010727606])
}

# 캐주얼 사용자의 상위 이용 경로 좌표
casual_route_coords = {
    'Streeter Dr & Grand Ave to Streeter Dr & Grand Ave': ([41.892278, -87.612043], [41.892278, -87.612043]),
    'Ellis Ave & 60th St to Ellis Ave & 55th St': ([41.78509416666667, -87.60108833333334], [41.79430062054, -87.6014497734]),
    'DuSable Lake Shore Dr & Monroe St to DuSable Lake Shore Dr & Monroe St': ([41.880958, -87.616743], [41.880958, -87.616743]),
    'Ellis Ave & 55th St to Ellis Ave & 60th St': ([41.79430062054, -87.6014497734], [41.78509714636, -87.6010727606]),
    'DuSable Lake Shore Dr & Monroe St to Streeter Dr & Grand Ave': ([41.880958, -87.616743], [41.892278, -87.612043]),
    'Ellis Ave & 60th St to University Ave & 57th St': ([41.78509416666667, -87.60108833333334], [41.791478, -87.599861]),
    'University Ave & 57th St to Ellis Ave & 60th St': ([41.791512, -87.59993216666666], [41.78509714636, -87.6010727606]),
    'University Ave & 57th St to Kimbark Ave & 53rd St': ([41.791512, -87.59993216666666], [41.799568, -87.594747]),
    'Streeter Dr & Grand Ave to Millennium Park': ([41.892278, -87.612043], [41.881032, -87.624084]),
    'Sheffield Ave & Fullerton Ave to Greenview Ave & Fullerton Ave': ([41.92556283333333, -87.6537395], [41.92533, -87.6658])
}

# 지도 생성
m = folium.Map(location=[41.8781, -87.6298], zoom_start=12)

# 멤버 사용자의 경로 표시
for route, coords in member_route_coords.items():
    folium.PolyLine(coords, color="blue").add_to(m)

# 캐주얼 사용자의 경로 표시
for route, coords in casual_route_coords.items():
    folium.PolyLine(coords, color="red").add_to(m)

# 지도 표시
m.save("map.html")

import folium

# 캐주얼 사용자의 상위 이용 경로 좌표
casual_route_coords = {
    'Streeter Dr & Grand Ave to Streeter Dr & Grand Ave': ([41.892278, -87.612043], [41.892278, -87.612043]),
    'Ellis Ave & 60th St to Ellis Ave & 55th St': ([41.78509416666667, -87.60108833333334], [41.79430062054, -87.6014497734]),
    'DuSable Lake Shore Dr & Monroe St to DuSable Lake Shore Dr & Monroe St': ([41.880958, -87.616743], [41.880958, -87.616743]),
    'Ellis Ave & 55th St to Ellis Ave & 60th St': ([41.79430062054, -87.6014497734], [41.78509714636, -87.6010727606]),
    'DuSable Lake Shore Dr & Monroe St to Streeter Dr & Grand Ave': ([41.880958, -87.616743], [41.892278, -87.612043]),
    'Ellis Ave & 60th St to University Ave & 57th St': ([41.78509416666667, -87.60108833333334], [41.791478, -87.599861]),
    'University Ave & 57th St to Ellis Ave & 60th St': ([41.791512, -87.59993216666666], [41.78509714636, -87.6010727606]),
    'University Ave & 57th St to Kimbark Ave & 53rd St': ([41.791512, -87.59993216666666], [41.799568, -87.594747]),
    'Streeter Dr & Grand Ave to Millennium Park': ([41.892278, -87.612043], [41.881032, -87.624084]),
    'Sheffield Ave & Fullerton Ave to Greenview Ave & Fullerton Ave': ([41.92556283333333, -87.6537395], [41.92533, -87.6658])
}

# 이용 빈도
route_usage = {
    'Streeter Dr & Grand Ave to Streeter Dr & Grand Ave': 192,
    'Ellis Ave & 60th St to Ellis Ave & 55th St': 180,
    'DuSable Lake Shore Dr & Monroe St to DuSable Lake Shore Dr & Monroe St': 165,
    'Ellis Ave & 55th St to Ellis Ave & 60th St': 161,
    'DuSable Lake Shore Dr & Monroe St to Streeter Dr & Grand Ave': 155,
    'Ellis Ave & 60th St to University Ave & 57th St': 153,
    'University Ave & 57th St to Ellis Ave & 60th St': 133,
    'University Ave & 57th St to Kimbark Ave & 53rd St': 94,
    'Streeter Dr & Grand Ave to Millennium Park': 86,
    'Sheffield Ave & Fullerton Ave to Greenview Ave & Fullerton Ave': 81
}

# 지도 생성
m = folium.Map(location=[41.8781, -87.6298], zoom_start=12)

# 캐주얼 사용자의 경로 및 마커 표시
for route, coords in casual_route_coords.items():
    # 선의 굵기 설정 (이용 빈도에 따라 조정)
    line_weight = route_usage.get(route, 1) * 0.05  # 이용 빈도에 비례하여 선의 굵기를 조정

    # 경로 표시
    folium.PolyLine(coords, color="red", weight=line_weight,alpha=0.5).add_to(m)

    # 끝점에 마커 추가
    folium.Marker(coords[1], popup=route).add_to(m)

# 지도 저장
m.save("map.html")

# 'start_station_id'와 'end_station_id' 컬럼에서 중복 제거하고 스테이션 개수 계산
unique_stations = pd.concat([data['start_station_id'], data['end_station_id']]).unique()
number_of_stations = len(unique_stations)

# 결과 출력
print(f"중복 없는 스테이션의 총 개수: {number_of_stations}")

import folium


# 스테이션별 이용 빈도수 계산
station_usage_start = data['start_station_id'].value_counts()
station_usage_end = data['end_station_id'].value_counts()
station_usage = station_usage_start.add(station_usage_end, fill_value=0)

# 스테이션 위치 데이터 추출
station_locations = data.groupby('start_station_id').first()[['start_lat', 'start_lng']].dropna()

# 지도 생성
m = folium.Map(location=[station_locations['start_lat'].mean(), station_locations['start_lng'].mean()], zoom_start=12)

# 스테이션별 마커 추가
for station_id, row in station_locations.iterrows():
    usage = station_usage.get(station_id, 0)
    # 너무 큰 원을 방지하기 위한 크기 제한 설정
    radius = min(usage, 1000) * 2  # 최대 크기를 1000으로 제한
    folium.Circle(
        location=(row['start_lat'], row['start_lng']),
        radius=radius,
        color='blue',
        fill=True,
        fill_opacity=0.01,
        weight=0.1
    ).add_to(m)

# 지도 저장
m.save("map.html")

# 각 라이드가 시작된 요일 계산 (1 = 일요일, 7 = 토요일)
data['day_of_week'] = data['started_at'].dt.dayofweek + 1

# 전체 라이드의 요일별 빈도수 계산
overall_day_frequency = data['day_of_week'].value_counts().sort_index()

# 멤버와 캐주얼 사용자별 요일별 빈도수 계산
member_day_frequency = data[data['member_casual'] == 'member']['day_of_week'].value_counts().sort_index()
casual_day_frequency = data[data['member_casual'] == 'casual']['day_of_week'].value_counts().sort_index()

# 결과 출력
print("전체 요일별 빈도:  {0}".format(overall_day_frequency)),
print("회원 요일별 빈도:  {0}".format(member_day_frequency)),
print("비회원 요일별 빈도:  {0}".format(casual_day_frequency))

import matplotlib.pyplot as plt

# 전체 라이드의 요일별 빈도수 계산
overall_day_frequency = data['day_of_week'].value_counts().sort_index()

# 멤버와 캐주얼 사용자별 요일별 빈도수 계산
member_day_frequency = data[data['member_casual'] == 'member']['day_of_week'].value_counts().sort_index()
casual_day_frequency = data[data['member_casual'] == 'casual']['day_of_week'].value_counts().sort_index()

# 요일별 분포 그래프 그리기
plt.figure(figsize=(12, 6))
plt.plot(overall_day_frequency.index, overall_day_frequency.values, label='Overall', marker='o')
plt.plot(member_day_frequency.index, member_day_frequency.values, label='Member', marker='o')
plt.plot(casual_day_frequency.index, casual_day_frequency.values, label='Casual', marker='o')

# 그래프 제목 및 레이블 설정
plt.title('Day of the Week Usage Frequency')
plt.xlabel('Day of the Week (1=Sunday, 7=Saturday)')
plt.ylabel('Number of Rides')
plt.xticks(range(1, 8))
plt.legend()

# 그래프 표시
plt.show()

# 요일별 이용량 계산
data['day_of_week'] = data['started_at'].dt.day_name()

# 각 요일별 가장 높은 이용량을 가진 시간대 찾기
best_marketing_times = data.groupby('day_of_week')['started_at'].apply(lambda x: x.dt.hour.mode().iloc[0]).reset_index()

# 결과 출력
print("요일별 가장 적합한 마케팅 시간대:")
for index, row in best_marketing_times.iterrows():
    print(f"{row['day_of_week']}: {row['started_at']} 시")

# 요일과 시간대별 이용 횟수 계산
usage_by_day_hour = data.groupby(['day_of_week', 'hour_of_day']).size().reset_index(name='이용횟수')

# 상위 10개 조합 선택
top_10_times = usage_by_day_hour.nlargest(10, '이용횟수')

# 결과 출력
print("상위 10개 요일과 시간대별 이용 횟수:")
for index, row in top_10_times.iterrows():
    print(f"{row['day_of_week']} {row['hour_of_day']}시 - 이용횟수: {row['이용횟수']}회")

# 캐주얼 사용자만 선택
casual_data = data[data['member_casual'] == 'casual']

# 요일과 시간대별 이용 횟수 계산
usage_by_day_hour = casual_data.groupby(['day_of_week', 'hour_of_day']).size().reset_index(name='이용횟수')

# 상위 10개 조합 선택
top_10_times = usage_by_day_hour.nlargest(10, '이용횟수')

# 결과 출력
print("캐주얼 사용자 상위 10개 요일과 시간대별 이용 횟수:")
for index, row in top_10_times.iterrows():
    print(f"{row['day_of_week']} {row['hour_of_day']}시 - 이용횟수: {row['이용횟수']}회")

import folium

# 관심 있는 스테이션 이름 리스트
stations = [
    'Shedd Aquarium',
    'Streeter Dr & Grand Ave',
    'Millennium Park',
    'DuSable Lake Shore Dr & Monroe St',
    'Kingsbury St & Kinzie St',
    'Clark St & Newport St',
    'LaSalle St & Illinois St',
    'Clark St & Elm St',
    'Wabash Ave & Grand Ave',
    'Michigan Ave & 8th St'
]

# 각 스테이션의 빈도수 (위치 정보는 가상 데이터로 대체)
station_frequencies = {
    'Shedd Aquarium': 433,
    'Streeter Dr & Grand Ave': 406,
    'Millennium Park': 300,
    'DuSable Lake Shore Dr & Monroe St': 298,
    'Kingsbury St & Kinzie St': 246,
    'Clark St & Newport St': 242,
    'LaSalle St & Illinois St': 236,
    'Clark St & Elm St': 231,
    'Wabash Ave & Grand Ave': 231,
    'Michigan Ave & 8th St': 227
}

# 각 스테이션의 위도와 경도 정보 (가상 데이터)
station_coordinates = {
    'Shedd Aquarium': {'start_lat': 41.867226, 'start_lng': -87.615355},
    'Streeter Dr & Grand Ave': {'start_lat': 41.892278, 'start_lng': -87.612043},
    'Millennium Park': {'start_lat': 41.881032, 'start_lng': -87.624084},
    'DuSable Lake Shore Dr & Monroe St': {'start_lat': 41.880958, 'start_lng': -87.616743},
    'Kingsbury St & Kinzie St': {'start_lat': 41.889177, 'start_lng': -87.638506},
    'Clark St & Newport St': {'start_lat': 41.944540, 'start_lng': -87.654678},
    'LaSalle St & Illinois St': {'start_lat': 41.890755, 'start_lng': -87.632009},
    'Clark St & Elm St': {'start_lat': 41.902973, 'start_lng': -87.631280},
    'Wabash Ave & Grand Ave': {'start_lat': 41.891738, 'start_lng': -87.626937},
    'Michigan Ave & 8th St': {'start_lat': 41.872773, 'start_lng': -87.623981}
}

# 지도 생성
map = folium.Map(location=[41.8781, -87.6298], zoom_start=13)

# 각 스테이션의 위치에 마커 추가
for station, freq in station_frequencies.items():
    coords = station_coordinates[station]
    folium.Circle(
        location=[coords['start_lat'], coords['start_lng']],
        radius=freq/2,  # 빈도수에 따라 크기 조정
        color='blue',
        fill=True,
        fill_color='blue',
        popup=f"{station}: {freq}회"
    ).add_to(map)

# 지도 표시
map

# 캐주얼 사용자의 상위 이용 경로 좌표 및 이용 빈도를 바탕으로 세련된 지도를 생성하는 코드를 작성합니다.

import folium

# 캐주얼 사용자의 상위 이용 경로 좌표
casual_route_coords = {
    'Streeter Dr & Grand Ave to Streeter Dr & Grand Ave': ([41.892278, -87.612043], [41.892278, -87.612043]),
    'Ellis Ave & 60th St to Ellis Ave & 55th St': ([41.78509416666667, -87.60108833333334], [41.79430062054, -87.6014497734]),
    'DuSable Lake Shore Dr & Monroe St to DuSable Lake Shore Dr & Monroe St': ([41.880958, -87.616743], [41.880958, -87.616743]),
    'Ellis Ave & 55th St to Ellis Ave & 60th St': ([41.79430062054, -87.6014497734], [41.78509714636, -87.6010727606]),
    'DuSable Lake Shore Dr & Monroe St to Streeter Dr & Grand Ave': ([41.880958, -87.616743], [41.892278, -87.612043]),
    'Ellis Ave & 60th St to University Ave & 57th St': ([41.78509416666667, -87.60108833333334], [41.791478, -87.599861]),
    'University Ave & 57th St to Ellis Ave & 60th St': ([41.791512, -87.59993216666666], [41.78509714636, -87.6010727606]),
    'University Ave & 57th St to Kimbark Ave & 53rd St': ([41.791512, -87.59993216666666], [41.799568, -87.594747]),
    'Streeter Dr & Grand Ave to Millennium Park': ([41.892278, -87.612043], [41.881032, -87.624084]),
    'Sheffield Ave & Fullerton Ave to Greenview Ave & Fullerton Ave': ([41.92556283333333, -87.6537395], [41.92533, -87.6658])
}

# 이용 빈도
route_usage = {
    'Streeter Dr & Grand Ave to Streeter Dr & Grand Ave': 192,
    'Ellis Ave & 60th St to Ellis Ave & 55th St': 180,
    'DuSable Lake Shore Dr & Monroe St to DuSable Lake Shore Dr & Monroe St': 165,
    'Ellis Ave & 55th St to Ellis Ave & 60th St': 161,
    'DuSable Lake Shore Dr & Monroe St to Streeter Dr & Grand Ave': 155,
    'Ellis Ave & 60th St to University Ave & 57th St': 153,
    'University Ave & 57th St to Ellis Ave & 60th St': 133,
    'University Ave & 57th St to Kimbark Ave & 53rd St': 94,
    'Streeter Dr & Grand Ave to Millennium Park': 86,
    'Sheffield Ave & Fullerton Ave to Greenview Ave & Fullerton Ave': 81
}

# 지도 생성
m = folium.Map(location=[41.8781, -87.6298], zoom_start=12)

# 캐주얼 사용자의 경로 및 마커 표시
for route, coords in casual_route_coords.items():
    # 선의 굵기 설정 (이용 빈도에 따라 조정)
    line_weight = route_usage.get(route, 1) * 0.05  # 이용 빈도에 비례하여 선의 굵기를 조정

    # 경로 표시
    folium.PolyLine(coords, color="blue", weight=line_weight, opacity=0.8).add_to(m)

    # 시작점과 끝점에 마커 추가
    folium.Marker(coords[0], icon=folium.Icon(color='green'), popup=f"Start: {route.split(' to ')[0]}").add_to(m)
    folium.Marker(coords[1], icon=folium.Icon(color='red'), popup=f"End: {route.split(' to ')[1]}").add_to(m)

# 지도 표시
m

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

# 실제 데이터 사용
data = {
    'day_of_week': ['Thursday', 'Thursday', 'Sunday', 'Saturday', 'Thursday', 'Tuesday', 'Saturday', 'Saturday', 'Thursday', 'Friday'],
    'hour_of_day': [17, 16, 15, 15, 15, 17, 12, 16, 18, 15],
    '이용횟수': [579, 564, 561, 541, 528, 494, 489, 485, 484, 480]
}
df = pd.DataFrame(data)

# 요일과 시간대별로 피벗 테이블 생성
pivot_table = df.pivot("day_of_week", "hour_of_day", "이용횟수")

plt.figure(figsize=(10, 7))
sns.heatmap(pivot_table, annot=True, fmt=".0f", linewidths=.5, cmap="Blues")

plt.title('Heatmap of Usage Frequency by Day and Hour for Casual Users', fontsize=16)
plt.ylabel('Day of Week', fontsize=12)

# x축 레이블을 'PM'으로 변경
hour_labels_pm = [f'{hour} PM' for hour in range(12, 19)]
plt.xticks(np.arange(0.5, len(hour_labels_pm) + 0.5), hour_labels_pm)

plt.xlabel('Hour of Day', fontsize=12)

plt.show()